 对于这种长指令，我建议使用以下几种优化方式来让代码更清晰易维护：

## **方法1: 使用多行字符串与格式化**

```python
# 定义指令模板
GEMINI_ANALYSIS_PROMPT = """
Analyze this industrial operation video and extract the following information:

Equipment Information:
- Machine ID: {machine_id}
- Part ID: {part_id}
- Process: {process_id} (Step {process_number})

Please identify and describe:

1. Detailed operation steps (in chronological order)
   - Include precise timestamps for each step
   - Describe hand movements and tool usage
   - Note any quality checkpoints

2. Key quality inspection points and inspection methods
   - Visual inspection requirements
   - Measurement procedures
   - Acceptance criteria

3. Safety precautions
   - PPE requirements
   - Hazard identification
   - Emergency procedures

4. Tool and material usage
   - Required tools list
   - Material specifications
   - Handling procedures

5. Potential risk points
   - Safety hazards
   - Quality risks
   - Process deviations

6. Operation standards and requirements
   - Time standards
   - Quality standards
   - Performance metrics

Output Requirements:
- Format: Structured JSON
- Timestamps must be clearly marked (MM:SS format)
- Include confidence scores for each identification
- Provide detailed descriptions for each step
"""

# 使用时格式化指令
def analyze_video_with_gemini(video_file, metadata):
    formatted_prompt = GEMINI_ANALYSIS_PROMPT.format(
        machine_id=metadata.get('machine_id', 'N/A'),
        part_id=metadata.get('part_id', 'N/A'),
        process_id=metadata.get('process_id', 'N/A'),
        process_number=metadata.get('process_number', 'N/A')
    )
    
    response = client.models.generate_content(
        model="gemini-2.0-flash",
        contents=[video_file, formatted_prompt]
    )
    
    return response.text
```

## **方法2: 使用配置类管理指令**

```python
from dataclasses import dataclass
from pathlib import Path

@dataclass
class AnalysisConfig:
    machine_id: str
    part_id: str
    process_id: str
    process_number: int
    
    def build_analysis_prompt(self) -> str:
        base_prompt = Path("prompts/gemini_analysis.txt").read_text()
        return base_prompt.format(
            machine_id=self.machine_id,
            part_id=self.part_id,
            process_id=self.process_id,
            process_number=self.process_number
        )

# 使用示例
config = AnalysisConfig(
    machine_id="M001",
    part_id="P001", 
    process_id="PROC001",
    process_number=1
)

response = client.models.generate_content(
    model="gemini-2.0-flash",
    contents=[my_file, config.build_analysis_prompt()]
)
```

## **方法3: 创建专用的GeminiAnalyzer类**

```python
class GeminiVideoAnalyzer:
    def __init__(self, client):
        self.client = client
        self.model = "gemini-2.0-flash"
        
    def _build_prompt(self, metadata: dict) -> str:
        """构建分析提示词"""
        equipment_info = f"""
Equipment Information:
- Machine ID: {metadata.get('machine_id', 'Unknown')}
- Part ID: {metadata.get('part_id', 'Unknown')}
- Process: {metadata.get('process_id', 'Unknown')} (Step {metadata.get('process_number', 0)})
"""
        
        analysis_requirements = """
Please identify and describe:

1. Detailed operation steps (in chronological order)
   - Include precise timestamps for each step
   - Describe hand movements and tool usage
   - Note any quality checkpoints

2. Key quality inspection points and inspection methods
   - Visual inspection requirements  
   - Measurement procedures
   - Acceptance criteria

3. Safety precautions
   - PPE requirements
   - Hazard identification
   - Emergency procedures

4. Tool and material usage
   - Required tools list
   - Material specifications
   - Handling procedures

5. Potential risk points
   - Safety hazards
   - Quality risks
   - Process deviations

6. Operation standards and requirements
   - Time standards
   - Quality standards
   - Performance metrics
"""

        output_format = """
Output Requirements:
- Format: Structured JSON
- Timestamps must be clearly marked (MM:SS format)  
- Include confidence scores for each identification
- Provide detailed descriptions for each step

Example JSON structure:
{
  "operation_steps": [
    {
      "step_number": 1,
      "timestamp": "00:15",
      "description": "...",
      "tools_used": [...],
      "safety_notes": "...",
      "quality_checkpoint": true/false
    }
  ],
  "quality_points": [...],
  "safety_requirements": [...],
  "risk_assessment": [...]
}
"""
        
        return f"""
Analyze this industrial operation video and extract the following information:

{equipment_info}
{analysis_requirements}
{output_format}
"""
    
    def analyze_video(self, video_file, metadata: dict) -> dict:
        """分析视频并返回结构化结果"""
        prompt = self._build_prompt(metadata)
        
        try:
            response = self.client.models.generate_content(
                model=self.model,
                contents=[video_file, prompt]
            )
            
            # 解析JSON响应
            import json
            result = json.loads(response.text)
            return result
            
        except json.JSONDecodeError:
            # 如果返回的不是有效JSON，返回原始文本
            return {"raw_response": response.text}
        except Exception as e:
            return {"error": str(e)}

# 使用示例
analyzer = GeminiVideoAnalyzer(client)
metadata = {
    'machine_id': 'M001',
    'part_id': 'P001', 
    'process_id': 'PROC001',
    'process_number': 1
}

result = analyzer.analyze_video(my_file, metadata)
print(json.dumps(result, indent=2, ensure_ascii=False))
```

## **方法4: 使用外部配置文件**

创建 `prompts/gemini_analysis.yaml`:
```yaml
base_prompt: |
  Analyze this industrial operation video and extract the following information:
  
  Equipment Information:
  - Machine ID: {machine_id}
  - Part ID: {part_id}
  - Process: {process_id} (Step {process_number})

analysis_sections:
  - name: "operation_steps"
    description: "Detailed operation steps (in chronological order)"
    requirements:
      - "Include precise timestamps for each step"
      - "Describe hand movements and tool usage"
      - "Note any quality checkpoints"
      
  - name: "quality_points"
    description: "Key quality inspection points and inspection methods"
    requirements:
      - "Visual inspection requirements"
      - "Measurement procedures"
      - "Acceptance criteria"

output_format:
  type: "JSON"
  timestamp_format: "MM:SS"
  include_confidence: true
```

Python代码：
```python
import yaml

class PromptManager:
    def __init__(self, config_file="prompts/gemini_analysis.yaml"):
        with open(config_file, 'r', encoding='utf-8') as f:
            self.config = yaml.safe_load(f)
    
    def build_prompt(self, metadata: dict) -> str:
        base = self.config['base_prompt'].format(**metadata)
        
        sections = []
        for i, section in enumerate(self.config['analysis_sections'], 1):
            section_text = f"{i}. {section['description']}\n"
            for req in section['requirements']:
                section_text += f"   - {req}\n"
            sections.append(section_text)
        
        output_info = f"""
Output Requirements:
- Format: {self.config['output_format']['type']}
- Timestamps: {self.config['output_format']['timestamp_format']} format
- Include confidence scores: {self.config['output_format']['include_confidence']}
"""
        
        return base + "\n\nPlease identify and describe:\n\n" + "\n".join(sections) + output_info

# 使用
prompt_manager = PromptManager()
prompt = prompt_manager.build_prompt(metadata)

response = client.models.generate_content(
    model="gemini-2.0-flash",
    contents=[my_file, prompt]
)
```

## **推荐方案**

我推荐使用**方法3（GeminiVideoAnalyzer类）**，因为它：

1. **代码结构清晰**：逻辑分离，易于维护
2. **错误处理完善**：包含JSON解析和异常处理
3. **可扩展性强**：可以轻松添加新功能
4. **使用简单**：封装复杂性，提供简洁接口
5. **返回结构化数据**：直接返回可用的字典格式

这样你的主要业务逻辑就变得非常简洁：
```python
analyzer = GeminiVideoAnalyzer(client)
result = analyzer.analyze_video(video_file, metadata)
# 直接使用结构化的result数据
```
